<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Подготовка к собеседованию по JavaScript</title>
  <style>
    /* Добавьте стили CSS здесь для красивого дизайна */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 0;
      background-color: #f4f4f4;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    h1 {
      color: #333;
    }

    h2 {
      color: #555;
    }

    p {
      line-height: 1.5;
    }

    /* Добавьте другие стили по мере необходимости */
  </style>
</head>
<body>
<div class="container">
  <h1>Подготовка к собеседованию по JavaScript</h1>

  <h2>Переменные и Область видимости</h2>
  <ul>
    <li><a href="#question1">Что такое переменная? Как объявить?</a></li>
    <p>
      Переменная в JavaScript - это именованное хранилище данных. Для объявления переменных используются ключевые слова: `var`, `let` и `const`. Например:
      ```javascript
      var x = 10;
      let y = "Привет";
      const z = true;
      ```
    </p>

    <li><a href="#question2">Всплытие переменных (hoisting)</a></li>
    <p>
      Всплытие (hoisting) в JavaScript означает, что объявления переменных и функций перемещаются в начало своей области видимости. Например:
      ```javascript
      console.log(a); // undefined
      var a = 5;
      ```
      Переменная `a` поднимается (hoisted) вверх, но ей присваивается значение только на следующей строке. Поэтому в первой строке выводится `undefined`.
    </p>

    <li><a href="#question3">use strict</a></li>
    <p>
      `'use strict'` - это строка, которая используется для включения строгого режима в JavaScript. Строгий режим предоставляет более строгую проверку кода и исправляет некоторые неявные ошибки. Он объявляется в начале скрипта или функции.
    </p>

    <li><a href="#question4">В чём отличие let, const от var?</a></li>
    <p>
      Основное отличие между `var`, `let` и `const` заключается в их области видимости и возможности переназначения:
      - `var` имеет функциональную область видимости и может быть переназначен.
      - `let` и `const` имеют блочную область видимости, и `let` может быть переназначен, а `const` - нет.
    </p>

    <li><a href="#question5">Можно ли изменять объект внутри const?</a></li>
    <p>
      Да, объект, объявленный с помощью `const`, может быть изменен. `const` ограничивает только переназначение переменной, но не изменение ее содержимого. Например:
      ```javascript
      const person = { name: "John" };
      person.name = "Jane"; // Допустимо
      ```
    </p>
  </ul>
  <h2>Типы данных</h2>
  <ul>
    <li><a href="#question6">Какие есть типы данных в JavaScript?</a></li>
    <p>
      В JavaScript есть несколько основных типов данных, включая:
      - `number` для чисел (целых и с плавающей точкой)
      - `string` для строк
      - `boolean` для логических значений (true или false)
      - `object` для объектов
      - `undefined` для неопределенных значений
      - `null` для отсутствия значения
      - `symbol` для уникальных идентификаторов (ES6)
    </p>

    <li><a href="#question7">Тип Symbol</a></li>
    <p>
      `Symbol` - это новый тип данных, добавленный в ECMAScript 6 (ES6). Он представляет собой уникальное и неизменяемое значение, которое часто используется для создания уникальных ключей в объектах.
    </p>

    <li><a href="#question8">Как копируются объекты?</a></li>
    <p>
      Копирование объектов может быть выполнено несколькими способами:
      - Поверхностное копирование с помощью оператора `...` (spread) или `Object.assign()`.
      - Глубокое копирование с помощью рекурсивных функций или библиотек, таких как lodash.
    </p>

    <li><a href="#question9">Как определить тип значения?</a></li>
    <p>
      Для определения типа значения в JavaScript можно использовать оператор `typeof`. Например:
      ```javascript
      typeof 42; // "number"
      typeof "Hello"; // "string"
      typeof true; // "boolean"
      ```
    </p>

    <li><a href="#question10">typeof null?</a></li>
    <p>
      Оператор `typeof null` возвращает "object". Это историческая ошибка в языке JavaScript.
    </p>

    <li><a href="#question11">Отличие == от ===</a></li>
    <p>
      Оператор `==` выполняет неявное преобразование типов и сравнивает значения на равенство. Оператор `===` сравнивает значения на равенство без преобразования типов и учитывает строгое равенство.
    </p>

    <li><a href="#question12">Преобразования типов</a></li>
    <p>
      Преобразования типов в JavaScript могут быть явными (с использованием функций, таких как `parseInt()` или `Number()`) или неявными (преобразование при выполнении операций). Например:
      ```javascript
      var x = "42";
      var y = Number(x); // Явное преобразование в число
      var z = x * 1; // Неявное преобразование в число
      ```
    </p>
  </ul>
  <h2>Операторы</h2>
  <ul>
    <li><a href="#question13">Что такое оператор? Унарные, бинарные операторы</a></li>
    <p>
      Оператор - это символ или ключевое слово, которое выполняет операцию над одним или несколькими операндами в выражении. Операнды могут быть значениями или переменными. Операторы могут быть унарными (работают с одним операндом) или бинарными (работают с двумя операндами).
      Примеры операторов:
      - Арифметические: `+`, `-`, `*`, `/`
      - Сравнения: `==`, `!=`, `===`, `!==`
      - Логические: `&&`, `||`, `!`
    </p>
  </ul>
  <h2>Циклы</h2>
  <ul>
    <li><a href="#question14">Что такое цикл?</a></li>
    <p>
      Цикл в программировании - это конструкция, которая позволяет выполнять один и тот же набор инструкций множество раз. Он позволяет автоматизировать выполнение повторяющихся задач.
    </p>

    <li><a id="15">В чём отличие for от while?</a></li>
    <p>
      `for` и `while` - это два различных типа циклов в JavaScript. Главное отличие между ними заключается в структуре и способе определения условия завершения цикла.
      - `for` используется, когда заранее известно количество итераций. Он имеет начальное условие, условие завершения и инструкцию обновления.
      - `while` используется, когда условие завершения неизвестно заранее. Он просто проверяет условие перед каждой итерацией.
    </p>

    <li><a href="#question16">Пример цикла, который никогда не закончится</a></li>
    <p>
      Вот пример бесконечного цикла с использованием `while`:
      ```javascript
      while (true) {
      // Бесконечное выполнение
      }
      ```
      Этот цикл никогда не завершится, так как условие `true` всегда истинно.
    </p>


  </ul>
  <h2>Ветвление (Условные операторы)</h2>
  <ul>
    <li><a href="#question17">Что такое ветвление? (Условные операторы)</a></li>
    <p>
      Ветвление в программировании - это механизм, который позволяет выполнять разные блоки кода в зависимости от выполнения определенных условий. В JavaScript, для реализации ветвления, используются условные операторы, такие как `if`, `else if`, `else`, `switch`.
    </p>

    <li><a href="#question18">Пример switch case и аналога через if else</a></li>
    <p>
      Пример использования `switch`:
      ```javascript
      switch (day) {
      case 'Понедельник':
      console.log('Рабочий день');
      break;
      case 'Вторник':
      console.log('Рабочий день');
      break;
      case 'Среда':
      console.log('Рабочий день');
      break;
      case 'Четверг':
      console.log('Рабочий день');
      break;
      case 'Пятница':
      console.log('Рабочий день');
      break;
      case 'Суббота':
      console.log('Выходной');
      break;
      case 'Воскресенье':
      console.log('Выходной');
      break;
      default:
      console.log('Неизвестный день');
      }
      ```

      Аналогичный пример с использованием `if else`:
      ```javascript
      if (day === 'Понедельник' || day === 'Вторник' || day === 'Среда' || day === 'Четверг' || day === 'Пятница') {
      console.log('Рабочий день');
      } else if (day === 'Суббота' || day === 'Воскресенье') {
      console.log('Выходной');
      } else {
      console.log('Неизвестный день');
      }
      ```
    </p>

    <li><a href="#question19">Что такое оператор "тернарный"? Как он работает?</a></li>
    <p>
      Оператор "тернарный" (`? :`) - это условный оператор, который позволяет выбирать одно из двух значений в зависимости от условия. Он имеет следующий синтаксис: `условие ? значение1 : значение2`. Если условие истинно, то возвращается `значение1`, иначе возвращается `значение2`.
      Пример:
      ```javascript
      var age = 20;
      var status = (age >= 18) ? 'Совершеннолетний' : 'Несовершеннолетний';
      console.log(status); // Выведет 'Совершеннолетний'
      ```
    </p>
  </ul>

  <h2>Массивы</h2>
  <ul>
    <li><a href="#question20">Что такое массивы в JavaScript?</a></li>
    <p>
      Массивы в JavaScript - это упорядоченные коллекции данных, которые могут содержать элементы разных типов. Они используются для хранения и управления списками элементов, обеспечивая удобный доступ и манипуляции с данными.
    </p>

    <li><a href="#question21">Разница между map и forEach</a></li>
    <p>
      Разница между `map` и `forEach` заключается в том, как они обрабатывают и возвращают результат:
      - `forEach` выполняет функцию обратного вызова для каждого элемента массива, но не создает новый массив. Он просто изменяет оригинальный массив, если это необходимо.
      - `map` также выполняет функцию обратного вызова для каждого элемента, но создает новый массив из результатов вызовов функции обратного вызова, не изменяя оригинальный массив.
    </p>

    <li><a href="#question22">Разница между map и forEach</a></li>
    <p>
      Опять же, разница между `map` и `forEach` заключается в том, как они обрабатывают и возвращают результат. Пожалуйста, ознакомьтесь с предыдущим ответом для подробной информации.
    </p>

    <li><a href="#question23">Что из перечисленного меняет оригинальный массив? forEach, sort, filter, map, slice, splice, reduce</a></li>
    <p>
      Из перечисленных методов, оригинальный массив изменяют следующие: `sort`, `splice`, `push`, `pop`, `shift`, `unshift`. Остальные методы (`forEach`, `filter`, `map`, `slice`, `reduce`) не изменяют оригинальный массив, а либо возвращают новый массив, либо выполняют какие-то операции без изменения исходного массива.
    </p>
  </ul>

  <h2>Объекты</h2>

  <ul>
    <li><a href="#question24">Как можно создать объект?</a></li>
    <p>
      В JavaScript объект можно создать с помощью фигурных скобок `{}` или оператора `new` для создания объекта с использованием конструктора функции.
    </p>

    <li><a href="#question25">Как можно скопировать объект? Object.assign()</a></li>
    <p>
      Для копирования объекта в JavaScript можно использовать метод `Object.assign()`, который копирует свойства одного или нескольких объектов в целевой объект.
    </p>

    <li><a href="#question26">Вычисляемые свойства объектов</a></li>
    <p>
      Вычисляемые свойства объектов - это возможность создавать свойства объекта с вычисляемыми именами, используя квадратные скобки `[]`.
    </p>

    <li><a href="#question27">Что такое Object.create?</a></li>
    <p>
      `Object.create()` - это метод, который создает новый объект с указанным прототипом (прототипом другого объекта) или `null`, если прототип не указан.
    </p>

    <li><a href="#question28">Что делает оператор new?</a></li>
    <p>
      Оператор `new` используется для создания экземпляра объекта с помощью конструктора функции. Он создает новый пустой объект, привязывает его к прототипу функции и вызывает конструктор функции для инициализации объекта.
    </p>

    <li><a href="#question29">Что такое window?</a></li>
    <p>
      `window` - это глобальный объект в браузерной среде JavaScript. Он представляет окно браузера и предоставляет доступ к глобальным переменным и функциям.
    </p>
    <h2>Функции</h2>
    <li><a href="#question30">Что такое функция?</a></li>
    <p>
      Функция в JavaScript - это блок кода, который выполняет определенную задачу. Она может принимать аргументы и возвращать значение.
    </p>

    <li><a href="#question31">Что такое замыкание?</a></li>
    <p>
      Замыкание - это функция, которая запоминает свою лексическую область видимости и имеет доступ к переменным из этой области даже после завершения выполнения.
    </p>

    <li><a href="#question32">В чём отличие Function Expression от Function Declaration?</a></li>
    <p>
      Function Declaration объявляет функцию в текущей области видимости, в то время как Function Expression создает функцию как выражение и присваивает ее переменной.
    </p>

    <li><a href="#question33">Что такое IIFE (Immediately Invoked Function Expression)?</a></li>
    <p>
      IIFE - это функция, которая вызывается немедленно после объявления. Она обычно используется для создания локальной области видимости.
    </p>
    <li><a href="#question34">Функции стрелки</a></li>
    <p>
      Стрелочные функции (Arrow functions) - это сокращенный синтаксис для объявления функций в JavaScript. Они не имеют своего собственного контекста `this`.
    </p>
    <h2>Контекст</h2>
    <li><a href="#question35">Какой контекст у стрелочной функции?</a></li>
    <p>
      Контекст (this) у стрелочной функции берется из окружающего лексического контекста, в котором она была объявлена.
    </p>

    <li><a href="#question36">Как получить доступ ко всем аргументам функции?</a></li>
    <p>
      Для доступа ко всем аргументам функции можно использовать объект `arguments`, который доступен внутри функции и содержит все переданные аргументы в виде массивоподобного объекта.
    </p>

    <li><a href="#question37">Что такое конструктор?</a></li>
    <p>
      Конструктор - это функция, которая используется для создания новых экземпляров объектов. Конструкторы обычно начинаются с заглавной буквы.
    </p>

    <li><a href="#question38">Что такое каррирование?</a></li>
    <p>
      Каррирование - это техника функционального программирования, которая заключается в преобразовании функции с множеством аргументов в последовательность функций с одним аргументом.
    </p>

    <li><a href="#question39">Что такое область видимости?</a></li>
    <p>
      Область видимости определяет, где в коде доступны переменные и функции. В JavaScript есть глобальная и локальная область видимости.
    </p>

    <li><a href="#question40">Что такое частичное применение функции?</a></li>
    <p>
      Частичное применение функции - это техника, при которой функция вызывается с частью аргументов, а затем возвращает новую функцию, ожидающую оставшиеся аргументы.
    </p>

    <li><a href="#question41">Что такое контекст вызова? (this)</a></li>
    <p>
      Контекст вызова (this) в JavaScript определяет, к чему относится ключевое слово `this` внутри функции. Он зависит от способа вызова функции.
    </p>

    <li><a href="#question42">this в методе, конструкторе</a></li>
    <p>
      В методе объекта `this` ссылается на сам объект. В конструкторе `this` ссылается на новый созданный объект.
    </p>

    <li><a href="#question43">Функции привязки контекста (call, apply, bind)</a></li>
    <p>
      Функции `call`, `apply` и `bind` используются для явного указания контекста (this) при вызове функции.
    </p>

    <li><a href="#question44">Когда создается Lexical Environment?</a></li>
    <p>
      Lexical Environment создается каждый раз при входе в новую область видимости, например, при вызове функции или блока.
    </p>
    <li><a href="#question45">setTimeout с 0 через сколько мс будет?</a></li>
    <p>
      `setTimeout` с задержкой 0 миллисекунд не означает, что функция выполнится мгновенно. Она будет помещена в конец очереди событий и выполнится после завершения текущих операций.
    </p>

    <li><a href="#question46">Контекст исполнения функции. В какой момент времени устанавливается контекст?</a></li>
    <p>
      Контекст исполнения функции (this) устанавливается в момент вызова функции, в зависимости от способа вызова функции.
    </p>

    <li><a href="#question47">Каким может быть контекст? (Вызов метода из объекта, call bind apply, new, потеря контекста)</a></li>
    <p>
      Контекст функции может быть определен разными способами, включая вызов функции как метода объекта, использование методов `call`, `bind`, `apply`, создание объекта через `new`, и потерю контекста при передаче функции в другой контекст.
    </p>
    <h2>События</h2>
    <li><a href="#question48">Фазы событий (всплытие, перехват)</a></li>
    <p>
      В событийной модели браузера события проходят через фазы всплытия и перехвата. Всплытие означает, что событие сначала срабатывает на самом вложенном элементе и затем всплывает вверх по дереву DOM. Перехват - это фаза, когда событие спускается сверху вниз.
    </p>

    <li><a href="#question49">Отличие stopPropagation и stopImmediatePropagation от preventDefault</a></li>
    <p>
      `stopPropagation` и `stopImmediatePropagation` используются для остановки распространения события. `preventDefault` предотвращает стандартное действие браузера.
    </p>
    <h2>Общее</h2>
    <li><a href="#question50">Обработка ошибок. Как обрабатывать ошибки в JS? try...catch...finally. Объяснить, как работает catch и finally</a></li>
    <p>
      Для обработки ошибок в JavaScript используется конструкция `try...catch...finally`. `try` блок содержит код, который может вызвать ошибку. Если ошибка возникает, выполнение переходит в `catch` блок, где можно обработать ошибку. `finally` блок выполняется в любом случае, независимо от того, возникла ошибка или нет.
    </p>

    <li><a href="#question51">Модули. Что такое модуль? Зачем?</a></li>
    <p>
      Модули - это способ организации кода в отдельные файлы для лучшей структурированности и повторного использования. Они позволяют изолировать переменные и функции внутри модуля и экспортировать только необходимые элементы для использования в других частях приложения.
    </p>

    <li><a href="#question52">Event loop (событийный цикл)</a></li>
    <p>
      Event loop - это механизм, который позволяет JavaScript обрабатывать асинхронные операции, такие как события и таймеры, не блокируя основной поток выполнения.
    </p>

    <li><a href="#question53">Микрозадачи в event loop</a></li>
    <p>
      Микрозадачи (microtasks) - это задачи, которые выполняются внутри текущего цикла событий после выполнения всех макрозадач (событий из очереди задач). Примерами микрозадач являются промисы и обработчики `then`.
    </p>
    <li><a href="#question54">Что такое асинхронность в JS?</a></li>
    <p>
      Асинхронность в JavaScript означает, что некоторые операции выполняются в фоновом режиме, не блокируя основной поток выполнения. Это позволяет обрабатывать операции, которые требуют времени, такие как запросы к серверу или загрузка файлов, без блокировки интерфейса пользователя.
    </p>

    <li><a href="#question55">Promise</a></li>
    <p>
      Промисы (Promises) - это специальный объект в JavaScript, предназначенный для работы с асинхронными операциями. Они позволяют обрабатывать результаты асинхронных задач, таких как HTTP-запросы, в удобном и последовательном стиле, избегая "колбэков".
    </p>

    <li><a href="#question56">Что такое chaining?</a></li>
    <p>
      Chaining - это прием использования промисов для последовательного выполнения асинхронных операций. Вы можете вызывать методы промиса, такие как `.then()`, в цепочке, чтобы определить, что делать после выполнения предыдущей асинхронной задачи.
    </p>

    <li><a href="#question57">CORS, кросс-доменные запросы, JSONP</a></li>
    <p>
      CORS (Cross-Origin Resource Sharing) - это механизм, позволяющий веб-страницам запрашивать ресурсы с других доменов. Кросс-доменные запросы и JSONP - это методы обхода политики безопасности same-origin policy, которая обычно запрещает такие запросы.
    </p>

    <li><a href="#question58">Методы HTTP, GET, POST</a></li>
    <p>
      HTTP (Hypertext Transfer Protocol) - это протокол для передачи данных в Интернете. GET и POST - это два основных метода HTTP-запросов. GET используется для получения данных, а POST - для отправки данных на сервер.
    </p>

    <li><a href="#question59">Что такое HTTP Header?</a></li>
    <p>
      HTTP-заголовки (HTTP headers) - это метаданные, отправляемые вместе с HTTP-запросами и ответами. Они содержат информацию о типе контента, кодировке, кэшировании и другие параметры.
    </p>

    <li><a href="#question60">Какие бывают статусы ответа?</a></li>
    <p>
      Статус ответа HTTP указывает на результат выполнения запроса. Например, статус 200 означает успешный запрос, а статус 404 означает, что ресурс не найден.
    </p>

    <li><a href="#question61">Какие еще есть варианты обмена данными клиент-сервер?</a></li>
    <p>
      Кроме HTTP, есть другие протоколы и методы обмена данными, такие как WebSocket для двусторонней связи в реальном времени и GraphQL для более гибкого запроса данных с сервера.
    </p>

    <li><a href="#question62">Что такое Web API?</a></li>
    <p>
      Web API - это интерфейсы и методы, предоставляемые браузером для взаимодействия с веб-страницей и веб-сервером. Примерами Web API являются DOM API для управления HTML-документами и Fetch API для отправки HTTP-запросов.
    </p>

    <li><a href="#question63">Что делает Promise.all?</a></li>
    <p>
      `Promise.all` - это метод, который позволяет выполнить массив промисов параллельно и дождаться завершения всех промисов. Он возвращает новый промис, который разрешается, когда все промисы в массиве разрешаются, и отклоняется, если хотя бы один из промисов отклоняется.
    </p>

    <li><a href="#question64">Promise.race</a></li>
    <p>
      `Promise.race` - это метод, который возвращает промис, разрешенный или отклоненный как только один из промисов в массиве разрешится или отклонится. Это полезно, когда вы хотите выполнить какую-то операцию при первом успешном или ошибочном завершении асинхронных задач.
    </p>

    <li><a href="#question65">Что такое WebSocket?</a></li>
    <p>
      WebSocket - это протокол для двусторонней связи между клиентом и сервером в реальном времени. Он позволяет устанавливать постоянное соединение между браузером и сервером, что полезно для чата, игр и других приложений, требующих мгновенной передачи данных.
    </p>

    <li><a href="#question66">Геттеры-сеттеры. Зачем нужны</a></li>
    <p>
      Геттеры и сеттеры - это методы объекта, которые используются для получения и установки значений его свойств. Они позволяют контролировать доступ к данным объекта и выполнять дополнительную логику при чтении и записи свойств.
    </p>

    <li><a href="#question67">Дескрипторы, enumerable</a></li>
    <p>
      Дескрипторы - это объекты, которые определяют атрибуты свойств объекта, такие как доступность для перечисления (enumerable), возможность записи (writable), геттеры и сеттеры. Они используются при определении свойств с помощью метода `Object.defineProperty`.
    </p>

    <li><a href="#question68">Что такое ESMAScript?</a></li>
    <p>
      ES (ECMAScript) - это стандарт, описывающий язык JavaScript. ESMA (European Computer Manufacturers Association) - это организация, разрабатывающая стандарты для информационных систем. Поэтому ESMA Script (или сокращенно ES) - это стандарт для языка JavaScript, определяющий его синтаксис и функциональность.
    </p>

    <li><a href="#question69">Какие есть способы хранения данных на клиенте?</a></li>
    <p>
      Существует несколько способов хранения данных на клиентской стороне веб-приложений, такие как использование куки (cookies), хранилище веб-приложений (Web Storage), IndexedDB, кэширование на стороне браузера и многое другое. Каждый из них имеет свои особенности и предназначение.
    </p>
  </ul>


</div>
</body>
</html>
